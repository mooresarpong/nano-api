class Class{static register(e){"undefined"!=typeof exports&&(exports[e.name]=e)}}Class.register(Class);class PlatformUtils{static isBrowser(){return"undefined"!=typeof window}static isNodeJs(){return!PlatformUtils.isBrowser()&&"object"==typeof process&&"function"==typeof require}static supportsWebRTC(){return!!(PlatformUtils.isBrowser()?window.RTCPeerConnection||window.webkitRTCPeerConnection:null)}static isOnline(){return!PlatformUtils.isBrowser()||!("onLine"in window.navigator)||window.navigator.onLine}}Class.register(PlatformUtils);class LogNative{constructor(){this._global_level=Log.INFO,this._tag_levels={};try{if(window.localStorage)try{let e=window.localStorage.getItem("log_tag_levels");e&&"string"==typeof e&&(e=JSON.parse(e)),e&&"object"==typeof e&&(this._tag_levels=e)}catch(e){console.warn("Failed to load log configuration from local storage.")}}catch(e){}}isLoggable(e,t){return e&&this._tag_levels[e]?this._tag_levels[e]<=t:this._tag_levels["*"]?this._tag_levels["*"]<=t:this._global_level<=t}setLoggable(e,t){e&&e.name&&(e=e.name),this._tag_levels[e]=t,window.localStorage&&window.localStorage.setItem("log_tag_levels",JSON.stringify(this._tag_levels))}msg(e,t,r){t&&t.name&&(t=t.name),this.isLoggable(t,e)&&(t&&r.unshift(t+":"),r.unshift(`[${Log.Level.toStringTag(e)} ${(new Date).toTimeString().substr(0,8)}]`),console.error&&e>=Log.ERROR?console.error.apply(console,r):console.warn&&e>=Log.WARNING?console.warn.apply(console,r):console.info&&e>=Log.INFO?console.info.apply(console,r):console.debug&&e>=Log.DEBUG?console.debug.apply(console,r):console.trace&&e<=Log.TRACE?console.trace.apply(console,r):console.log.apply(console,r))}}Class.register(LogNative);class Log{static get instance(){return Log._instance||(Log._instance=new Log(new LogNative)),Log._instance}constructor(e){this._native=e}setLoggable(e,t){this._native.setLoggable(e,t)}get level(){return this._native._global_level}set level(e){this._native._global_level=e}msg(e,t,r){if(this._native.isLoggable(t,e)){for(let e=0;e<r.length;++e)"function"==typeof r[e]&&(r[e]=r[e]()),"object"==typeof r[e]&&("function"==typeof r[e].toString?r[e]=r[e].toString():r[e].constructor&&r[e].constructor.name?r[e]=`{Object: ${r[e].constructor.name}}`:r[e]="{Object}");this._native.msg(e,t,r)}}static d(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.DEBUG,e,r)}static e(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.ERROR,e,r)}static i(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.INFO,e,r)}static v(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.VERBOSE,e,r)}static w(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.WARNING,e,r)}static t(e,t,...r){arguments.length>=2?(e=arguments[0],r=Array.prototype.slice.call(arguments,1)):(e=void 0,r=Array.prototype.slice.call(arguments,0)),Log.instance.msg(Log.TRACE,e,r)}}Log.Level={TRACE:1,VERBOSE:2,DEBUG:3,INFO:4,WARNING:5,ERROR:6,ASSERT:7,toStringTag:function(e){switch(e){case Log.TRACE:return"T";case Log.VERBOSE:return"V";case Log.DEBUG:return"D";case Log.INFO:return"I";case Log.WARNING:return"W";case Log.ERROR:return"E";case Log.ASSERT:return"A";default:return"*"}}},Log.TRACE=Log.Level.TRACE,Log.VERBOSE=Log.Level.VERBOSE,Log.DEBUG=Log.Level.DEBUG,Log.INFO=Log.Level.INFO,Log.WARNING=Log.Level.WARNING,Log.ERROR=Log.Level.ERROR,Log.ASSERT=Log.Level.ASSERT,Log._instance=null,Log.d.tag=(e=>Log.d.bind(null,e)),Log.e.tag=(e=>Log.e.bind(null,e)),Log.i.tag=(e=>Log.i.bind(null,e)),Log.v.tag=(e=>Log.v.bind(null,e)),Log.w.tag=(e=>Log.w.bind(null,e)),Log.t.tag=(e=>Log.t.bind(null,e)),Class.register(Log);class IWorker{static async createProxy(e,t,r){return new(IWorker.Proxy(e))(r,t)}static async startWorkerForProxy(e,t,r){return IWorker._workersSupported?(r||(r=`${Nimiq._path}worker.js`),IWorker.createProxy(e,t,new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${r.replace(/'/g,"")}');`]))))):(await IWorker._workerImplementation[e.name].init(t),IWorker._workerImplementation[e.name])}static async startWorkerPoolForProxy(e,t,r,i){return new(IWorker.Pool(e))(t=>IWorker.startWorkerForProxy(e,t,i),t,r).start()}static async stubBaseOnMessage(e){try{if("init"===e.data.command)if(IWorker._workerImplementation[e.data.args[0]]){const t=await IWorker._workerImplementation[e.data.args[0]].init(e.data.args[1]);self.postMessage({status:"OK",result:t,id:e.data.id})}else self.postMessage({status:"error",result:"Unknown worker!",id:e.data.id});else self.postMessage({status:"error",result:"Worker not yet initialized!",id:e.data.id})}catch(t){self.postMessage({status:"error",result:t,id:e.data.id})}}static get _workersSupported(){return"undefined"!=typeof Worker}static get areWorkersAsync(){return IWorker._workersSupported}static get _insideWebWorker(){return"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope}static get _global(){return"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:null}static prepareForWorkerUse(e,t){IWorker._insideWebWorker&&(self.onmessage=IWorker.stubBaseOnMessage),IWorker._workerImplementation=IWorker._workerImplementation||{},IWorker._workerImplementation[e.name]=t}static fireModuleLoaded(e="Module"){"function"==typeof IWorker._moduleLoadedCallbacks[e]&&(IWorker._moduleLoadedCallbacks[e](),IWorker._moduleLoadedCallbacks[e]=null)}static _loadBrowserScript(e,t){const r=document.getElementsByTagName("head")[0],i=document.createElement("script");i.type="text/javascript",i.src=e;const s=()=>window.setTimeout(t,100);i.onreadystatechange=s,i.onload=s,r.appendChild(i)}static Proxy(e){const t=class extends e{constructor(t,r){return super(),this._name=r,this._messageId=0,this._worker=t,this._worker.onmessage=this._receive.bind(this),this._waiting=new Map,this._invoke("init",[e.name,r]).then(()=>this)}_receive(e){const t=this._waiting.get(e.data.id);t?(this._waiting.delete(e.data.id),"OK"===e.data.status?t.resolve(e.data.result):"error"===e.data.status&&t.error(e.data.result)):Log.w(WorkerProxy,"Unknown reply",e)}importScript(e){return this._invoke("importScript",[e])}importWasm(e,t="Module"){return this._invoke("importWasm",[e,t])}_invoke(e,t=[]){return new Promise((r,i)=>{const s={command:e,args:t,id:this._messageId++};this._waiting.set(s.id,{resolve:r,error:i}),this._worker.postMessage(s)})}destroy(){return this._invoke("destroy")}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}static Stub(e){const t=class extends e{constructor(){super()}_result(e,t,r){self.postMessage({status:t,result:r,id:e.data.id})}_onmessage(e){try{const t=this._invoke(e.data.command,e.data.args);t instanceof Promise?t.then(t=>{this._result(e,"OK",t)}):this._result(e,"OK",t)}catch(t){this._result(e,"error",t.message||t)}}importScript(e,t="Module"){if(t&&IWorker._global[t]&&IWorker._global[t].asm)return!1;"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`),"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`);const r=IWorker._global[t]||{};return new Promise(async(i,s)=>{if(t)switch(typeof r.preRun){case"undefined":r.preRun=(()=>i(!0));break;case"function":r.preRun=[r,()=>i(!0)];break;case"object":r.preRun.push(()=>i(!0))}"function"==typeof importScripts?(await new Promise(r=>{IWorker._moduleLoadedCallbacks[t]=r,importScripts(e)}),IWorker._global[t]=IWorker._global[t](r),t||i(!0)):"object"==typeof window?(await new Promise(t=>{IWorker._loadBrowserScript(e,t)}),IWorker._global[t]=IWorker._global[t](r),t||i(!0)):"function"==typeof require?(IWorker._global[t]=require(e)(r),t||i(!0)):s("No way to load scripts.")})}importWasm(e,t="Module"){return"undefined"!=typeof Nimiq&&Nimiq._path&&(e=`${Nimiq._path}${e}`),"string"==typeof __dirname&&-1===e.indexOf("/")&&(e=`${__dirname}/${e}`),IWorker._global.WebAssembly?new Promise(r=>{try{if(PlatformUtils.isNodeJs()){const i=function(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e[r];return t};require("fs").readFile(e,(s,n)=>{s?(Log.w(IWorker,`Failed to access WebAssembly module ${e}: ${s}`),r(!1)):(IWorker._global[t]=IWorker._global[t]||{},IWorker._global[t].wasmBinary=i(n),r(!0))})}else{const i=new XMLHttpRequest;i.open("GET",e,!0),i.responseType="arraybuffer",i.onload=function(){IWorker._global[t]=IWorker._global[t]||{},IWorker._global[t].wasmBinary=i.response,r(!0)},i.onerror=function(){Log.w(IWorker,`Failed to access WebAssembly module ${e}`),r(!1)},i.send(null)}}catch(t){Log.w(IWorker,`Failed to access WebAssembly module ${e}`),r(!1)}}):(Log.w(IWorker,"No support for WebAssembly available."),Promise.resolve(!1))}init(e){this._name=e,IWorker._insideWebWorker&&(self.name=e,self.onmessage=(e=>this._onmessage(e)))}_invoke(e,t){return this[e].apply(this,t)}destroy(){IWorker._insideWebWorker&&self.close()}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(){throw`Not implemented in IWorker Stub: ${r}`});return t}static Pool(e){const t=class extends e{constructor(e,t="pool",r=1){super(),this._proxyInitializer=e,this._name=t,this._poolSize=r,this._workers=[],this._freeWorkers=[],this._waitingCalls=[]}async start(){return await this._updateToSize(),this}get poolSize(){return this._poolSize}set poolSize(e){this._poolSize=e,this._updateToSize().catch(Log.w.tag(IWorker))}destroy(){return this._poolSize=0,this._updateToSize()}_invoke(e,t){return IWorker._workersSupported?new Promise((r,i)=>{this._waitingCalls.push({name:e,args:t,resolve:r,error:i});const s=this._freeWorkers.shift();s&&this._step(s).catch(Log.w.tag(IWorker))}):this._workers[0][e].apply(this._workers[0],t)}async _step(e){let t=this._waitingCalls.shift();for(;t;){try{t.resolve(await e[t.name].apply(e,t.args))}catch(e){t.error(e)}if(-1===this._workers.indexOf(e))return void e.destroy();t=this._waitingCalls.shift()}this._freeWorkers.push(e)}async _updateToSize(){"undefined"==typeof Worker&&this._poolSize>1&&(Log.d(IWorker,"Pool of size larger than 1 requires WebWorker support."),this._poolSize=1);const e=[];for(;this._workers.length+e.length<this._poolSize;)e.push(this._proxyInitializer(`${this._name}#${this._workers.length+e.length}`));const t=await Promise.all(e);for(const e of t)this._workers.push(e),this._step(e).catch(Log.w.tag(IWorker));for(;this._workers.length>this._poolSize;){const e=this._freeWorkers.shift()||this._workers.pop(),t=this._workers.indexOf(e);t>=0&&(this._workers.splice(t,1),e.destroy())}return this}};for(const r of Object.getOwnPropertyNames(e.prototype))"function"==typeof e.prototype[r]&&"constructor"!==r&&(t.prototype[r]=function(...e){return this._invoke(r,e)});return t}}IWorker._moduleLoadedCallbacks={},IWorker._workerImplementation={},Class.register(IWorker);class Crypto{static get lib(){return CryptoLib.instance}static async prepareSyncCryptoWorker(){const e=IWorker._workerImplementation[CryptoWorker.name];return await e.init("crypto"),Crypto._workerSync=e,e}static _cryptoWorkerSync(){if(null===Crypto._workerSync)throw new Error("Synchronous crypto worker not yet prepared");return Crypto._workerSync}static async _cryptoWorkerAsync(){return Crypto._workerAsync||(Crypto._workerAsync=await IWorker.startWorkerPoolForProxy(CryptoWorker,"crypto",4)),Crypto._workerAsync}static get publicKeyType(){return Uint8Array}static get publicKeySize(){return 32}static publicKeySerialize(e){return e}static publicKeyUnserialize(e){return e}static publicKeyDerive(e){return Crypto._cryptoWorkerSync().publicKeyDerive(e)}static get privateKeyType(){return Uint8Array}static get privateKeySize(){return 32}static privateKeySerialize(e){return e}static privateKeyUnserialize(e){return e}static privateKeyGenerate(){const e=new Uint8Array(Crypto.privateKeySize);return Crypto.lib.getRandomValues(e),e}static get keyPairType(){return Object}static keyPairGenerate(){return Crypto.keyPairDerive(Crypto.privateKeyGenerate())}static keyPairDerive(e){return{privateKey:e,publicKey:Crypto.publicKeyDerive(e)}}static keyPairPrivate(e){return e.privateKey}static keyPairPublic(e){return e.publicKey}static keyPairFromKeys(e,t){return{privateKey:e,publicKey:t}}static get signatureType(){return Uint8Array}static get signatureSize(){return 64}static signatureSerialize(e){return e}static signatureUnserialize(e){return e}static signatureCreate(e,t,r){return Crypto._cryptoWorkerSync().signatureCreate(e,t,r)}static signatureVerify(e,t,r){return Crypto._cryptoWorkerSync().signatureVerify(e,t,r)}static async blockVerify(e,t){return(await Crypto._cryptoWorkerAsync()).blockVerify(e,t,Block.GENESIS.HASH.serialize())}static get hashType(){return Uint8Array}static get hashSize(){return 32}static get blake2bSize(){return 32}static blake2bSync(e){return Crypto._cryptoWorkerSync().computeBlake2b(e)}static async blake2bAsync(e){return(await Crypto._cryptoWorkerAsync()).computeBlake2b(e)}static get argon2dSize(){return 32}static async argon2d(e){return(await Crypto._cryptoWorkerAsync()).computeArgon2d(e)}static get sha256Size(){return 32}static sha256(e){return Crypto._cryptoWorkerSync().computeSha256(e)}static get randomnessSize(){return 32}static get commitmentPairType(){return Object}static commitmentPairGenerate(){const e=new Uint8Array(Crypto.randomnessSize);return Crypto.lib.getRandomValues(e),Crypto._cryptoWorkerSync().commitmentCreate(e)}static commitmentPairFromValues(e,t){return{secret:e,commitment:t}}static commitmentPairRandomSecret(e){return e.secret}static commitmentPairCommitment(e){return e.commitment}static get randomSecretType(){return Uint8Array}static get randomSecretSize(){return 32}static randomSecretSerialize(e){return e}static randomSecretUnserialize(e){return e}static get commitmentType(){return Uint8Array}static get commitmentSize(){return 32}static commitmentSerialize(e){return e}static commitmentUnserialize(e){return e}static get partialSignatureType(){return Uint8Array}static get partialSignatureSize(){return 32}static partialSignatureSerialize(e){return e}static partialSignatureUnserialize(e){return e}static hashPublicKeys(e){return Crypto._cryptoWorkerSync().publicKeysHash(e)}static delinearizePublicKey(e,t){const r=Crypto._cryptoWorkerSync(),i=r.publicKeysHash(e);return r.publicKeyDelinearize(t,i)}static delinearizePrivateKey(e,t,r){const i=Crypto._cryptoWorkerSync(),s=i.publicKeysHash(e);return i.privateKeyDelinearize(r,t,s)}static delinearizeAndAggregatePublicKeys(e){const t=Crypto._cryptoWorkerSync(),r=t.publicKeysHash(e);return t.publicKeysDelinearizeAndAggregate(e,r)}static delinearizedPartialSignatureCreate(e,t,r,i,s,n){return Crypto._cryptoWorkerSync().delinearizedPartialSignatureCreate(r,e,t,i,s,n)}static aggregateCommitments(e){return Crypto._cryptoWorkerSync().commitmentsAggregate(e)}static aggregatePartialSignatures(e){const t=Crypto._cryptoWorkerSync();return e.reduce((e,r)=>t.scalarsAdd(e,r))}static combinePartialSignatures(e,t){const r=Crypto.aggregatePartialSignatures(t);return BufferUtils.concatTypedArrays(e,r)}static async kdf(e,t,r=256){return(await Crypto._cryptoWorkerAsync()).kdf(e,t,r)}static async manyPow(e){const t=await Crypto._cryptoWorkerAsync(),r=t.poolSize||1,i=[];let s=0;for(let t=0;t<r;++t)for(i.push([]);s<(t+1)/r*e.length;++s)i[t].push(e[s].serialize());const n=[];for(const e of i)n.push(t.computeArgon2dBatch(e));const o=(await Promise.all(n)).reduce((e,t)=>[...e,...t],[]);for(let t=0;t<e.length;++t)e[t]._pow=new Hash(o[t])}}Crypto._workerSync=null,Crypto._workerAsync=null,Class.register(Crypto);class CryptoWorker{async computeBlake2b(e){}async computeArgon2d(e){}async computeArgon2dBatch(e){}async computeSha256(e){}async kdf(e,t,r){}async publicKeyDerive(e){}async commitmentCreate(e){}async scalarsAdd(e,t){}async commitmentsAggregate(e){}async publicKeysHash(e){}async publicKeyDelinearize(e,t){}async publicKeysDelinearizeAndAggregate(e,t){}async privateKeyDelinearize(e,t,r){}async delinearizedPartialSignatureCreate(e,t,r,i,s,n){}async signatureCreate(e,t,r){}async signatureVerify(e,t,r){}async blockVerify(e,t,r){}}CryptoWorker.ARGON2_HASH_SIZE=32,CryptoWorker.BLAKE2_HASH_SIZE=32,CryptoWorker.SHA256_HASH_SIZE=32,CryptoWorker.PUBLIC_KEY_SIZE=32,CryptoWorker.PRIVATE_KEY_SIZE=32,CryptoWorker.MULTISIG_RANDOMNESS_SIZE=32,CryptoWorker.SIGNATURE_SIZE=64,CryptoWorker.PARTIAL_SIGNATURE_SIZE=32,CryptoWorker.SIGNATURE_HASH_SIZE=64,Class.register(CryptoWorker);class CryptoWorkerImpl extends(IWorker.Stub(CryptoWorker)){constructor(){super(),this._superInit=super.init}async init(e){IWorker._insideWebWorker&&(Crypto._workerSync=this,Crypto._workerAsync=this),await this._superInit.call(this,e),await this.importWasm("worker-wasm.wasm")?await this.importScript("worker-wasm.js"):await this.importScript("worker-js.js");const t=Module._get_static_memory_start(),r=Module._get_static_memory_size();if(r<CryptoWorker.PUBLIC_KEY_SIZE+CryptoWorker.PRIVATE_KEY_SIZE+CryptoWorker.SIGNATURE_SIZE)throw Error("Static memory too small");let i=t;this._pubKeyPointer=i,this._pubKeyBuffer=new Uint8Array(Module.HEAP8.buffer,i,CryptoWorker.PUBLIC_KEY_SIZE),i+=CryptoWorker.PUBLIC_KEY_SIZE,this._privKeyPointer=i,this._privKeyBuffer=new Uint8Array(Module.HEAP8.buffer,i,CryptoWorker.PRIVATE_KEY_SIZE),i+=CryptoWorker.PRIVATE_KEY_SIZE,this._signaturePointer=i,this._signatureBuffer=new Uint8Array(Module.HEAP8.buffer,i,CryptoWorker.SIGNATURE_SIZE),i+=CryptoWorker.SIGNATURE_SIZE,this._messagePointer=i,this._messageBuffer=new Uint8Array(Module.HEAP8.buffer,i,t+r-i)}computeBlake2b(e){let t;try{t=Module.stackSave();const r=Module.stackAlloc(CryptoWorker.BLAKE2_HASH_SIZE),i=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,i,e.length).set(e);const s=Module._nimiq_blake2(r,i,e.length);if(0!==s)throw s;const n=new Uint8Array(CryptoWorker.BLAKE2_HASH_SIZE);return n.set(new Uint8Array(Module.HEAPU8.buffer,r,CryptoWorker.BLAKE2_HASH_SIZE)),n}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==t&&Module.stackRestore(t)}}computeArgon2d(e){let t;try{t=Module.stackSave();const r=Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE),i=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,i,e.length).set(e);const s=Module._nimiq_argon2(r,i,e.length,512);if(0!==s)throw s;const n=new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);return n.set(new Uint8Array(Module.HEAPU8.buffer,r,CryptoWorker.ARGON2_HASH_SIZE)),n}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==t&&Module.stackRestore(t)}}computeArgon2dBatch(e){const t=[];let r;try{r=Module.stackSave();const i=Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE),s=Module.stackSave();for(const r of e){Module.stackRestore(s);const e=Module.stackAlloc(r.length);new Uint8Array(Module.HEAPU8.buffer,e,r.length).set(r);const n=Module._nimiq_argon2(i,e,r.length,512);if(0!==n)throw n;const o=new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);o.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.ARGON2_HASH_SIZE)),t.push(o)}return t}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}computeSha256(e){let t;try{t=Module.stackSave();const r=Module.stackAlloc(CryptoWorker.SHA256_HASH_SIZE),i=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,i,e.length).set(e),Module._nimiq_sha256(r,i,e.length);const s=new Uint8Array(CryptoWorker.SHA256_HASH_SIZE);return s.set(new Uint8Array(Module.HEAPU8.buffer,r,CryptoWorker.SHA256_HASH_SIZE)),s}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==t&&Module.stackRestore(t)}}kdf(e,t,r){let i;try{i=Module.stackSave();const s=Module.stackAlloc(CryptoWorker.ARGON2_HASH_SIZE),n=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e);const o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t);const a=Module._nimiq_kdf(s,n,e.length,o,t.length,512,r);if(0!==a)throw a;const l=new Uint8Array(CryptoWorker.ARGON2_HASH_SIZE);return l.set(new Uint8Array(Module.HEAPU8.buffer,s,CryptoWorker.ARGON2_HASH_SIZE)),l}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==i&&Module.stackRestore(i)}}publicKeyDerive(e){const t=new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);if(e.byteLength!==CryptoWorker.PRIVATE_KEY_SIZE)throw Error("Wrong buffer size.");return this._privKeyBuffer.set(e),Module._ed25519_public_key_derive(this._pubKeyPointer,this._privKeyPointer),this._privKeyBuffer.fill(0),t.set(this._pubKeyBuffer),t}commitmentCreate(e){let t;try{t=Module.stackSave();const r=Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE),i=Module.stackAlloc(CryptoWorker.PRIVATE_KEY_SIZE),s=Module.stackAlloc(e.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e);const n=Module._ed25519_create_commitment(i,r,s);if(1!==n)throw new Error(`Secret must not be 0 or 1: ${n}`);const o=new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE),a=new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);return o.set(new Uint8Array(Module.HEAPU8.buffer,r,CryptoWorker.PUBLIC_KEY_SIZE)),a.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.PRIVATE_KEY_SIZE)),{commitment:o,secret:a}}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==t&&Module.stackRestore(t)}}scalarsAdd(e,t){if(e.byteLength!==CryptoWorker.PARTIAL_SIGNATURE_SIZE||t.byteLength!==CryptoWorker.PARTIAL_SIGNATURE_SIZE)throw Error("Wrong buffer size.");let r;try{r=Module.stackSave();const i=Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE),s=Module.stackAlloc(e.length),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t),Module._ed25519_add_scalars(i,s,n);const o=new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);return o.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.PARTIAL_SIGNATURE_SIZE)),o}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}commitmentsAggregate(e){if(e.some(e=>e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE))throw Error("Wrong buffer size.");const t=new Uint8Array(e.length*CryptoWorker.PUBLIC_KEY_SIZE);for(let r=0;r<e.length;++r)t.set(e[r],r*CryptoWorker.PUBLIC_KEY_SIZE);let r;try{r=Module.stackSave();const i=Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE),s=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,t.length).set(t),Module._ed25519_aggregate_commitments(i,s,e.length);const n=new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);return n.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.PUBLIC_KEY_SIZE)),n}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}publicKeysHash(e){if(e.some(e=>e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE))throw Error("Wrong buffer size.");const t=new Uint8Array(e.length*CryptoWorker.PUBLIC_KEY_SIZE);for(let r=0;r<e.length;++r)t.set(e[r],r*CryptoWorker.PUBLIC_KEY_SIZE);let r;try{r=Module.stackSave();const i=Module.stackAlloc(CryptoWorker.SIGNATURE_HASH_SIZE),s=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,t.length).set(t),Module._ed25519_hash_public_keys(i,s,e.length);const n=new Uint8Array(CryptoWorker.SIGNATURE_HASH_SIZE);return n.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.SIGNATURE_HASH_SIZE)),n}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}publicKeyDelinearize(e,t){if(e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE||t.byteLength!==CryptoWorker.SIGNATURE_HASH_SIZE)throw Error("Wrong buffer size.");let r;try{r=Module.stackSave();const i=Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE),s=Module.stackAlloc(e.length),n=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,s,e.length).set(e),new Uint8Array(Module.HEAPU8.buffer,n,t.length).set(t),Module._ed25519_delinearize_public_key(i,n,s);const o=new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);return o.set(new Uint8Array(Module.HEAPU8.buffer,i,CryptoWorker.PUBLIC_KEY_SIZE)),o}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==r&&Module.stackRestore(r)}}publicKeysDelinearizeAndAggregate(e,t){if(e.some(e=>e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE)||t.byteLength!==CryptoWorker.SIGNATURE_HASH_SIZE)throw Error("Wrong buffer size.");const r=new Uint8Array(e.length*CryptoWorker.PUBLIC_KEY_SIZE);for(let t=0;t<e.length;++t)r.set(e[t],t*CryptoWorker.PUBLIC_KEY_SIZE);let i;try{i=Module.stackSave();const s=Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE),n=Module.stackAlloc(r.length),o=Module.stackAlloc(t.length);new Uint8Array(Module.HEAPU8.buffer,n,r.length).set(r),new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t),Module._ed25519_aggregate_delinearized_public_keys(s,o,n,e.length);const a=new Uint8Array(CryptoWorker.PUBLIC_KEY_SIZE);return a.set(new Uint8Array(Module.HEAPU8.buffer,s,CryptoWorker.PUBLIC_KEY_SIZE)),a}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==i&&Module.stackRestore(i)}}privateKeyDelinearize(e,t,r){if(e.byteLength!==CryptoWorker.PRIVATE_KEY_SIZE||t.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE||r.byteLength!==CryptoWorker.SIGNATURE_HASH_SIZE)throw Error("Wrong buffer size.");let i;try{i=Module.stackSave();const s=Module.stackAlloc(CryptoWorker.PUBLIC_KEY_SIZE),n=Module.stackAlloc(e.length),o=Module.stackAlloc(t.length),a=Module.stackAlloc(r.length);new Uint8Array(Module.HEAPU8.buffer,n,e.length).set(e),new Uint8Array(Module.HEAPU8.buffer,o,t.length).set(t),new Uint8Array(Module.HEAPU8.buffer,a,r.length).set(r),Module._ed25519_derive_delinearized_private_key(s,a,o,n);const l=new Uint8Array(CryptoWorker.PRIVATE_KEY_SIZE);return l.set(new Uint8Array(Module.HEAPU8.buffer,s,CryptoWorker.PRIVATE_KEY_SIZE)),l}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==i&&Module.stackRestore(i)}}delinearizedPartialSignatureCreate(e,t,r,i,s,n){if(e.some(e=>e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE)||t.byteLength!==CryptoWorker.PRIVATE_KEY_SIZE||r.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE||i.byteLength!==CryptoWorker.PRIVATE_KEY_SIZE||s.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE)throw Error("Wrong buffer size.");const o=new Uint8Array(e.length*CryptoWorker.PUBLIC_KEY_SIZE);for(let t=0;t<e.length;++t)o.set(e[t],t*CryptoWorker.PUBLIC_KEY_SIZE);let a;try{a=Module.stackSave();const l=Module.stackAlloc(CryptoWorker.PARTIAL_SIGNATURE_SIZE),c=Module.stackAlloc(o.length),h=Module.stackAlloc(t.length),u=Module.stackAlloc(r.length),_=Module.stackAlloc(i.length),d=Module.stackAlloc(s.length),g=Module.stackAlloc(n.length);new Uint8Array(Module.HEAPU8.buffer,c,o.length).set(o),new Uint8Array(Module.HEAPU8.buffer,h,t.length).set(t),new Uint8Array(Module.HEAPU8.buffer,u,r.length).set(r),new Uint8Array(Module.HEAPU8.buffer,_,i.length).set(i),new Uint8Array(Module.HEAPU8.buffer,d,s.length).set(s),new Uint8Array(Module.HEAPU8.buffer,g,n.length).set(n),Module._ed25519_delinearized_partial_sign(l,g,n.length,d,_,c,e.length,u,h);const y=new Uint8Array(CryptoWorker.PARTIAL_SIGNATURE_SIZE);return y.set(new Uint8Array(Module.HEAPU8.buffer,l,CryptoWorker.PARTIAL_SIGNATURE_SIZE)),y}catch(e){throw Log.w(CryptoWorkerImpl,e),e}finally{void 0!==a&&Module.stackRestore(a)}}signatureCreate(e,t,r){const i=new Uint8Array(CryptoWorker.SIGNATURE_SIZE),s=r.byteLength;if(s>this._messageBuffer.byteLength||t.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE||e.byteLength!==CryptoWorker.PRIVATE_KEY_SIZE)throw Error("Wrong buffer size.");return this._messageBuffer.set(r),this._pubKeyBuffer.set(t),this._privKeyBuffer.set(e),Module._ed25519_sign(this._signaturePointer,this._messagePointer,s,this._pubKeyPointer,this._privKeyPointer),this._privKeyBuffer.fill(0),i.set(this._signatureBuffer),i}signatureVerify(e,t,r){const i=t.byteLength;if(r.byteLength!==CryptoWorker.SIGNATURE_SIZE||t.byteLength>this._messageBuffer.byteLength||e.byteLength!==CryptoWorker.PUBLIC_KEY_SIZE)throw Error("Wrong buffer size.");return this._signatureBuffer.set(r),this._messageBuffer.set(t),this._pubKeyBuffer.set(e),!!Module._ed25519_verify(this._signaturePointer,this._messagePointer,i,this._pubKeyPointer)}async blockVerify(e,t,r){Block.GENESIS.HASH=Hash.unserialize(new SerialBuffer(r));const i=Block.unserialize(new SerialBuffer(e)),s=await i.computeVerify(t),n=await i.header.pow(),o=await i.interlink.hash(),a=await i.body.hash();return{valid:s,pow:n.serialize(),interlinkHash:o.serialize(),bodyHash:a.serialize()}}}IWorker.prepareForWorkerUse(CryptoWorker,new CryptoWorkerImpl);class NumberUtils{static isUint8(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT8_MAX}static isUint16(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT16_MAX}static isUint32(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT32_MAX}static isUint64(e){return Number.isInteger(e)&&e>=0&&e<=NumberUtils.UINT64_MAX}static randomUint32(){return Math.floor(Math.random()*(NumberUtils.UINT32_MAX+1))}static randomUint64(){return Math.floor(Math.random()*(NumberUtils.UINT64_MAX+1))}}NumberUtils.UINT8_MAX=255,NumberUtils.UINT16_MAX=65535,NumberUtils.UINT32_MAX=4294967295,NumberUtils.UINT64_MAX=Number.MAX_SAFE_INTEGER,Class.register(NumberUtils);class BufferUtils{static toAscii(e){return String.fromCharCode.apply(null,new Uint8Array(e))}static fromAscii(e){const t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t}static _codePointTextDecoder(e){if("undefined"==typeof TextDecoder)throw new Error("TextDecoder not supported");if(null===BufferUtils._ISO_8859_15_DECODER)throw new Error("TextDecoder does not supprot iso-8859-15");if(void 0===BufferUtils._ISO_8859_15_DECODER)try{BufferUtils._ISO_8859_15_DECODER=new TextDecoder("iso-8859-15")}finally{BufferUtils._ISO_8859_15_DECODER=null}return BufferUtils._ISO_8859_15_DECODER.decode(e).replace("€","¤").replace("Š","¦").replace("š","¨").replace("Ž","´").replace("ž","¸").replace("Œ","¼").replace("œ","½").replace("Ÿ","¾")}static _tripletToBase64(e){return BufferUtils._BASE64_LOOKUP[e>>18&63]+BufferUtils._BASE64_LOOKUP[e>>12&63]+BufferUtils._BASE64_LOOKUP[e>>6&63]+BufferUtils._BASE64_LOOKUP[63&e]}static _base64encodeChunk(e,t,r){let i;const s=[];for(let n=t;n<r;n+=3)i=(e[n]<<16&16711680)+(e[n+1]<<8&65280)+(255&e[n+2]),s.push(BufferUtils._tripletToBase64(i));return s.join("")}static _base64fromByteArray(e){let t;const r=e.length,i=r%3;let s="";const n=[];for(let t=0,s=r-i;t<s;t+=16383)n.push(BufferUtils._base64encodeChunk(e,t,t+16383>s?s:t+16383));return 1===i?(t=e[r-1],s+=BufferUtils._BASE64_LOOKUP[t>>2],s+=BufferUtils._BASE64_LOOKUP[t<<4&63],s+="=="):2===i&&(t=(e[r-2]<<8)+e[r-1],s+=BufferUtils._BASE64_LOOKUP[t>>10],s+=BufferUtils._BASE64_LOOKUP[t>>4&63],s+=BufferUtils._BASE64_LOOKUP[t<<2&63],s+="="),n.push(s),n.join("")}static toBase64(e){if(PlatformUtils.isNodeJs())return new Buffer(e).toString("base64");if("undefined"!=typeof TextDecoder&&null!==BufferUtils._ISO_8859_15_DECODER)try{return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(e)))}catch(e){}return BufferUtils._base64fromByteArray(new Uint8Array(e))}static fromBase64(e){return new SerialBuffer(Uint8Array.from(atob(e),e=>e.charCodeAt(0)))}static toBase64Url(e){return BufferUtils.toBase64(e).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,".")}static fromBase64Url(e){return new SerialBuffer(Uint8Array.from(atob(e.replace(/_/g,"/").replace(/-/g,"+").replace(/\./g,"=")),e=>e.charCodeAt(0)))}static toBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){let r,i,s,n=3,o=0,a="";for(s=0;s<e.length;s++)a+=t[31&(i=o|(r=e[s])>>n)],n>5&&(a+=t[31&(i=r>>(n-=5))]),o=r<<(n=5-n),n=8-n;for(3!==n&&(a+=t[31&o]);a.length%8!=0&&33===t.length;)a+=t[32];return a}static fromBase32(e,t=BufferUtils.BASE32_ALPHABET.NIMIQ){const r=[];t.toUpperCase().split("").forEach((e,t)=>{e in r||(r[e]=t)});let i,s=8,n=0,o=[];return e.toUpperCase().split("").forEach(e=>{33===t.length&&e===t[32]||(i=255&r[e],(s-=5)>0?n|=i<<s:s<0?(o.push(n|i>>-s),n=i<<(s+=8)&255):(o.push(n|i),s=8,n=0))}),8!==s&&0!==n&&o.push(n),new Uint8Array(o)}static toHex(e){let t="";for(let r=0;r<e.length;r++){const i=e[r];t+=BufferUtils.HEX_ALPHABET[i>>>4],t+=BufferUtils.HEX_ALPHABET[15&i]}return t}static fromHex(e){return e=e.trim(),StringUtils.isHexBytes(e)?new SerialBuffer(Uint8Array.from(e.match(/.{2}/g)||[],e=>parseInt(e,16))):null}static concatTypedArrays(e,t){const r=new e.constructor(e.length+t.length);return r.set(e,0),r.set(t,e.length),r}static equals(e,t){if(e.length!==t.length)return!1;const r=new Uint8Array(e),i=new Uint8Array(t);for(let t=0;t<e.length;t++)if(r[t]!==i[t])return!1;return!0}static compare(e,t){if(e.length<t.length)return-1;if(e.length>t.length)return 1;for(let r=0;r<e.length;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0}static xor(e,t){const r=new Uint8Array(e.byteLength);for(let i=0;i<e.byteLength;++i)r[i]=e[i]^t[i];return r}}BufferUtils.BASE64_ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",BufferUtils.BASE32_ALPHABET={RFC4648:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",RFC4648_HEX:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",NIMIQ:"0123456789ABCDEFGHJKLMNPQRSTUVXY"},BufferUtils.HEX_ALPHABET="0123456789abcdef",BufferUtils._BASE64_LOOKUP=[];for(let e=0,t=BufferUtils.BASE64_ALPHABET.length;e<t;++e)BufferUtils._BASE64_LOOKUP[e]=BufferUtils.BASE64_ALPHABET[e];Class.register(BufferUtils);class SerialBuffer extends Uint8Array{constructor(e){super(e),this._view=new DataView(this.buffer),this._readPos=0,this._writePos=0}subarray(e,t){return ArrayUtils.subarray(this,e,t)}get readPos(){return this._readPos}set readPos(e){if(e<0||e>this.byteLength)throw`Invalid readPos ${e}`;this._readPos=e}get writePos(){return this._writePos}set writePos(e){if(e<0||e>this.byteLength)throw`Invalid writePos ${e}`;this._writePos=e}reset(){this._readPos=0,this._writePos=0}read(e){const t=this.subarray(this._readPos,this._readPos+e);return this._readPos+=e,t}write(e){this.set(e,this._writePos),this._writePos+=e.byteLength}readUint8(){return this._view.getUint8(this._readPos++)}writeUint8(e){this._view.setUint8(this._writePos++,e)}readUint16(){const e=this._view.getUint16(this._readPos);return this._readPos+=2,e}writeUint16(e){this._view.setUint16(this._writePos,e),this._writePos+=2}readUint32(){const e=this._view.getUint32(this._readPos);return this._readPos+=4,e}writeUint32(e){this._view.setUint32(this._writePos,e),this._writePos+=4}readUint64(){const e=this._view.getUint32(this._readPos)*Math.pow(2,32)+this._view.getUint32(this._readPos+4);if(!NumberUtils.isUint64(e))throw new Error("Malformed value");return this._readPos+=8,e}writeUint64(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");this._view.setUint32(this._writePos,Math.floor(e/Math.pow(2,32))),this._view.setUint32(this._writePos+4,e),this._writePos+=8}readVarUint(){const e=this.readUint8();return e<253?e:253===e?this.readUint16():254===e?this.readUint32():this.readUint64()}writeVarUint(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");e<253?this.writeUint8(e):e<=65535?(this.writeUint8(253),this.writeUint16(e)):e<=4294967295?(this.writeUint8(254),this.writeUint32(e)):(this.writeUint8(255),this.writeUint64(e))}static varUintSize(e){if(!NumberUtils.isUint64(e))throw new Error("Malformed value");return e<253?1:e<=65535?3:e<=4294967295?5:9}readFloat64(){const e=this._view.getFloat64(this._readPos);return this._readPos+=8,e}writeFloat64(e){this._view.setFloat64(this._writePos,e),this._writePos+=8}readString(e){const t=this.read(e);return BufferUtils.toAscii(t)}writeString(e,t){if(StringUtils.isMultibyte(e)||e.length!==t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r)}readPaddedString(e){const t=this.read(e);let r=0;for(;r<e&&0!==t[r];)r++;const i=new Uint8Array(t.buffer,t.byteOffset,r);return BufferUtils.toAscii(i)}writePaddedString(e,t){if(StringUtils.isMultibyte(e)||e.length>t)throw"Malformed value/length";const r=BufferUtils.fromAscii(e);this.write(r);const i=t-r.byteLength;this.write(new Uint8Array(i))}readVarLengthString(){const e=this.readUint8();if(this._readPos+e>this.length)throw"Malformed length";const t=this.read(e);return BufferUtils.toAscii(t)}writeVarLengthString(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");const t=BufferUtils.fromAscii(e);this.writeUint8(t.byteLength),this.write(t)}static varLengthStringSize(e){if(StringUtils.isMultibyte(e)||!NumberUtils.isUint8(e.length))throw new Error("Malformed value");return 1+e.length}}Class.register(SerialBuffer);class MinerWorker{async multiMine(e,t,r,i){}}Class.register(MinerWorker);class MinerWorkerImpl extends(IWorker.Stub(MinerWorker)){constructor(){super(),this._superInit=super.init}async init(e){await this._superInit.call(this,e),await this.importWasm("worker-wasm.wasm")?await this.importScript("worker-wasm.js"):await this.importScript("worker-js.js")}async multiMine(e,t,r,i){const s=new Uint8Array(32);let n,o;try{n=Module._malloc(s.length),o=Module._malloc(e.length),Module.HEAPU8.set(e,o);const a=Module._nimiq_argon2_target(n,o,e.length,t,r,i,512);return a!==i&&(s.set(new Uint8Array(Module.HEAPU8.buffer,n,s.length)),{hash:s,nonce:a})}catch(e){throw Log.w(MinerWorkerImpl,e),e}finally{void 0!==n&&Module._free(n),void 0!==o&&Module._free(o)}}}IWorker.prepareForWorkerUse(MinerWorker,new MinerWorkerImpl);class MinerWorkerPool extends(IWorker.Pool(MinerWorker)){constructor(e=1){if(super(e=>IWorker.startWorkerForProxy(MinerWorker,e),"miner",e),this._miningEnabled=!1,this._activeNonces=[],this._block=null,this._noncesPerRun=256,this._observable=new Observable,this._shareCompact=Policy.BLOCK_TARGET_MAX,this._runsPerCycle=1/0,this._cycleWait=100,this._superUpdateToSize=super._updateToSize,PlatformUtils.isNodeJs()){const e=require(`${__dirname}/nimiq_node`);this.multiMine=function(t,r,i,s){return new Promise((n,o)=>{e.nimiq_argon2_target_async(async e=>{try{if(e===s)n(!1);else{t.writePos-=4,t.writeUint32(e);const r=await Crypto.argon2d(t);n({hash:r,nonce:e})}}catch(e){o(e)}},t,r,i,s,512)})}}}get noncesPerRun(){return this._noncesPerRun}set noncesPerRun(e){this._noncesPerRun=e}get runsPerCycle(){return this._runsPerCycle}set runsPerCycle(e){this._runsPerCycle=e}get cycleWait(){return this._cycleWait}set cycleWait(e){this._cycleWait=e}on(e,t){this._observable.on(e,t)}off(e,t){this._observable.off(e,t)}async startMiningOnBlock(e,t=e.nBits){if(this._block=e,this._shareCompact=t,this._miningEnabled)this._activeNonces=[{minNonce:0,maxNonce:0}];else{await this._updateToSize(),this._activeNonces=[],this._miningEnabled=!0;for(let e=0;e<this.poolSize;++e)this._startMiner()}}stop(){this._miningEnabled=!1}async _updateToSize(){for(PlatformUtils.isNodeJs()||await this._superUpdateToSize.call(this);this._miningEnabled&&this._activeNonces.length<this.poolSize;)this._startMiner()}_startMiner(){const e=0===this._activeNonces.length?0:Math.max.apply(null,this._activeNonces.map(e=>e.maxNonce)),t={minNonce:e,maxNonce:e+this._noncesPerRun};this._activeNonces.push(t),this._singleMiner(t).catch(e=>Log.e(MinerWorkerPool,e))}async _singleMiner(e){let t=0;for(;this._miningEnabled&&(IWorker.areWorkersAsync||PlatformUtils.isNodeJs()||0===t)&&t<this._runsPerCycle;){t++;const r=this._block,i=await this.multiMine(r.header.serialize(),this._shareCompact,e.minNonce,e.maxNonce);if(i){const e=new Hash(i.hash);this._observable.fire("share",{block:r,nonce:i.nonce,hash:e})}else this._observable.fire("no-share",{nonce:e.maxNonce});if(this._activeNonces.length>this.poolSize)return void this._activeNonces.splice(this._activeNonces.indexOf(e),1);{const t=Math.max.apply(null,this._activeNonces.map(e=>e.maxNonce)),r={minNonce:t,maxNonce:t+this._noncesPerRun};this._activeNonces.splice(this._activeNonces.indexOf(e),1,r),e=r}}this._miningEnabled&&setTimeout(()=>this._singleMiner(e),this._cycleWait)}}Class.register(MinerWorkerPool);class ArrayUtils{static randomElement(e){return e[Math.floor(Math.random()*e.length)]}static subarray(e,t,r){function i(e,t,r){return e<t?t:e>r?r:e}void 0===t&&(t=0),void 0===r&&(r=e.byteLength),t=i(t,0,e.byteLength);let s=(r=i(r,0,e.byteLength))-t;return s<0&&(s=0),new Uint8Array(e.buffer,e.byteOffset+t,s)}static*k_combinations(e,t){const r=e.length;if(t>r)return;const i=Array.from(new Array(t),(e,t)=>t);yield i.map(t=>e[t]);const s=Array.from(new Array(t),(e,r)=>t-r-1);for(;;){let n=t-1,o=!1;for(n of s)if(i[n]!==n+r-t){o=!0;break}if(!o)return;i[n]+=1;for(const e of Array.from(new Array(t-n-1),(e,t)=>n+t+1))i[e]=i[e-1]+1;yield i.map(t=>e[t])}}}Class.register(ArrayUtils);class Assert{static that(e,t="Assertion failed"){if(!e)throw new Error(t)}}Class.register(Assert);class MerkleTree{static computeRoot(e,t=MerkleTree._hash){return MerkleTree._computeRoot(e,t)}static _computeRoot(e,t){const r=e.length;if(0===r)return Hash.light(new Uint8Array(0));if(1===r)return t(e[0]);const i=Math.round(r/2),s=e.slice(0,i),n=e.slice(i),o=MerkleTree._computeRoot(s,t),a=MerkleTree._computeRoot(n,t);return Hash.light(BufferUtils.concatTypedArrays(o.serialize(),a.serialize()))}static _hash(e){if(e instanceof Hash)return e;if("function"==typeof e.hash)return e.hash();if("function"==typeof e.serialize)return Hash.light(e.serialize());if(e instanceof Uint8Array)return Hash.light(e);throw new Error("MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method")}}Class.register(MerkleTree);class MerklePath{constructor(e){if(!Array.isArray(e)||!NumberUtils.isUint8(e.length)||e.some(e=>!(e instanceof MerklePathNode)))throw new Error("Malformed nodes");this._nodes=e}static compute(e,t,r=MerkleTree._hash){const i=r(t),s=[];return MerklePath._compute(e,i,s,r),new MerklePath(s)}static _compute(e,t,r,i){const s=e.length;let n;if(0===s)return{containsLeaf:!1,inner:n=Hash.light(new Uint8Array(0))};if(1===s)return{containsLeaf:(n=i(e[0])).equals(t),inner:n};const o=Math.round(s/2),a=e.slice(0,o),l=e.slice(o),{containsLeaf:c,inner:h}=MerklePath._compute(a,t,r,i),{containsLeaf:u,inner:_}=MerklePath._compute(l,t,r,i);return n=Hash.light(BufferUtils.concatTypedArrays(h.serialize(),_.serialize())),c?(r.push(new MerklePathNode(_,!1)),{containsLeaf:!0,inner:n}):u?(r.push(new MerklePathNode(h,!0)),{containsLeaf:!0,inner:n}):{containsLeaf:!1,inner:n}}computeRoot(e,t=MerkleTree._hash){let r=t(e);for(const e of this._nodes){const t=e.left,i=e.hash,s=new SerialBuffer(2*i.serializedSize);t&&i.serialize(s),r.serialize(s),t||i.serialize(s),r=Hash.light(s)}return r}static _compress(e){const t=e.length,r=Math.ceil(t/8),i=new Uint8Array(r);for(let r=0;r<t;r++)e[r].left&&(i[Math.floor(r/8)]|=128>>>r%8);return i}static unserialize(e){const t=e.readUint8(),r=Math.ceil(t/8),i=e.read(r),s=[];for(let r=0;r<t;r++){const t=0!=(i[Math.floor(r/8)]&128>>>r%8),n=Hash.unserialize(e);s.push(new MerklePathNode(n,t))}return new MerklePath(s)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._nodes.length),e.write(MerklePath._compress(this._nodes));for(const t of this._nodes)t.hash.serialize(e);return e}get serializedSize(){return 1+Math.ceil(this._nodes.length/8)+this._nodes.reduce((e,t)=>e+t.hash.serializedSize,0)}equals(e){return e instanceof MerklePath&&this._nodes.length===e._nodes.length&&this._nodes.every((t,r)=>t.equals(e._nodes[r]))}get nodes(){return this._nodes}}Class.register(MerklePath);class MerklePathNode{constructor(e,t){this._hash=e,this._left=t}get hash(){return this._hash}get left(){return this._left}equals(e){return e instanceof MerklePathNode&&this._hash.equals(e.hash)&&this._left===e.left}}Class.register(MerklePathNode);class Policy{static coinsToSatoshis(e){return Math.round(e*Policy.SATOSHIS_PER_COIN)}static satoshisToCoins(e){return e/Policy.SATOSHIS_PER_COIN}static supplyAfter(e){let t=Math.floor(e/Policy._supplyCacheInterval)*Policy._supplyCacheInterval;const r=(t=Math.max(0,Math.min(t,Policy._supplyCacheMax)))/Policy._supplyCacheInterval,i=Math.floor(e/Policy._supplyCacheInterval);let s=0===t?Policy.INITIAL_SUPPLY:Policy._supplyCache.get(t);for(let e=r;e<i;++e){t=e*Policy._supplyCacheInterval;const r=(e+1)*Policy._supplyCacheInterval-1;s=Policy._supplyAfter(s,r,t),Policy._supplyCache.set(r+1,s),Policy._supplyCacheMax=r+1}return Policy._supplyAfter(s,e,i*Policy._supplyCacheInterval)}static _supplyAfter(e,t,r=0){let i=e;for(let e=r;e<=t;++e)i+=Policy._blockRewardAt(i,e);return i}static blockRewardAt(e){const t=Policy.supplyAfter(e-1);return Policy._blockRewardAt(t,e)}static _blockRewardAt(e,t){if(t<=0)return 0;const r=Policy.TOTAL_SUPPLY-e;return t>=Policy.EMISSION_TAIL_START&&r>=Policy.EMISSION_TAIL_REWARD?Policy.EMISSION_TAIL_REWARD:(r-r%Policy.EMISSION_SPEED)/Policy.EMISSION_SPEED}static get BLOCK_TARGET_MAX(){return BlockUtils.compactToTarget(520159231)}}Policy.BLOCK_TIME=60,Policy.BLOCK_SIZE_MAX=1e6,Policy.DIFFICULTY_BLOCK_WINDOW=120,Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR=2,Policy.TRANSACTION_VALIDITY_WINDOW=120,Policy.SATOSHIS_PER_COIN=1e5,Policy.TOTAL_SUPPLY=21e14,Policy.INITIAL_SUPPLY=0,Policy.EMISSION_SPEED=Math.pow(2,22),Policy.EMISSION_TAIL_START=48692960,Policy.EMISSION_TAIL_REWARD=4e3,Policy.M=240,Policy.K=120,Policy.DELTA=.1,Policy.NUM_BLOCKS_VERIFICATION=250,Policy.NUM_SNAPSHOTS_MAX=20,Policy._supplyCache=new Map,Policy._supplyCacheMax=0,Policy._supplyCacheInterval=5e3,Class.register(Policy);class Primitive{constructor(e,t,r){if(t&&!(e instanceof t))throw new Error("Primitive: Invalid type");if(void 0!==r&&void 0!==e.length&&e.length!==r)throw new Error("Primitive: Invalid length");this._obj=e}equals(e){return e instanceof Primitive&&BufferUtils.equals(this.serialize(),e.serialize())}compare(e){if("function"==typeof this._obj.compare)return this._obj.compare(e._obj);if(this._obj.prototype===e._obj.prototype)return BufferUtils.compare(this.serialize(),e.serialize());throw new Error(`Incomparable types: ${this._obj.constructor.name} and ${e._obj.constructor.name}`)}hashCode(){return this.toBase64()}serialize(e){}toString(){return this.toBase64()}toBase64(){return BufferUtils.toBase64(this.serialize())}toHex(){return BufferUtils.toHex(this.serialize())}}Class.register(Primitive);class Hash extends Primitive{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Hash(t)}constructor(e,t=Hash.Algorithm.BLAKE2B){null===e&&(e=new Uint8Array(Hash.getSize(t))),super(e,Crypto.hashType,Hash.getSize(t)),this._algorithm=t}static light(e){return Hash.blake2b(e)}static blake2b(e){return new Hash(Crypto.blake2bSync(e),Hash.Algorithm.BLAKE2B)}static lightAsync(e){return Hash.blake2bAsync(e)}static async blake2bAsync(e){return new Hash(await Crypto.blake2bAsync(e),Hash.Algorithm.BLAKE2B)}static hard(e){return Hash.argon2d(e)}static async argon2d(e){return new Hash(await Crypto.argon2d(e),Hash.Algorithm.ARGON2D)}static sha256(e){return new Hash(Crypto.sha256(e),Hash.Algorithm.SHA256)}static compute(e,t){switch(t){case Hash.Algorithm.BLAKE2B:return Hash.blake2b(e);case Hash.Algorithm.SHA256:return Hash.sha256(e);default:throw new Error("Invalid hash algorithm")}}static unserialize(e,t=Hash.Algorithm.BLAKE2B){return new Hash(e.read(Hash.getSize(t)),t)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Hash.SIZE.get(this._algorithm)}get array(){return this._obj}get algorithm(){return this._algorithm}equals(e){return e instanceof Hash&&e._algorithm===this._algorithm&&super.equals(e)}static fromBase64(e){return new Hash(BufferUtils.fromBase64(e))}static fromHex(e){return new Hash(BufferUtils.fromHex(e))}static fromString(e){try{return Hash.fromHex(e)}catch(e){}try{return Hash.fromBase64(e)}catch(e){}throw new Error("Invalid hash format")}static isHash(e){return e instanceof Hash}static getSize(e){const t=Hash.SIZE.get(e);if(!t)throw new Error("Invalid hash algorithm");return t}}Hash.Algorithm={BLAKE2B:1,ARGON2D:2,SHA256:3},Hash.SIZE=new Map,Hash.SIZE.set(Hash.Algorithm.BLAKE2B,Crypto.blake2bSize),Hash.SIZE.set(Hash.Algorithm.ARGON2D,Crypto.argon2dSize),Hash.SIZE.set(Hash.Algorithm.SHA256,Crypto.sha256Size),Hash.NULL=new Hash(new Uint8Array(Crypto.hashSize)),Class.register(Hash);class PublicKey extends Primitive{static copy(e){return e?new PublicKey(new Uint8Array(e._obj)):e}constructor(e){super(e,Crypto.publicKeyType,Crypto.publicKeySize)}static derive(e){return new PublicKey(Crypto.publicKeyDerive(e._obj))}static sum(e){return(e=e.slice()).sort((e,t)=>e.compare(t)),new PublicKey(Crypto.delinearizeAndAggregatePublicKeys(e.map(e=>e._obj)))}static unserialize(e){return new PublicKey(Crypto.publicKeyUnserialize(e.read(Crypto.publicKeySize)))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(Crypto.publicKeySerialize(this._obj)),e}get serializedSize(){return Crypto.publicKeySize}equals(e){return e instanceof PublicKey&&super.equals(e)}hash(){return Hash.light(this.serialize())}hashAsync(){return Hash.lightAsync(this.serialize())}compare(e){return BufferUtils.compare(this._obj,e._obj)}toAddress(){return Address.fromHash(this.hash())}toPeerId(){return new PeerId(this.hash().subarray(0,16))}}Class.register(PublicKey);class Signature extends Primitive{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Signature(t)}constructor(e){super(e,Crypto.signatureType,Crypto.signatureSize)}static create(e,t,r){return new Signature(Crypto.signatureCreate(e._obj,t._obj,r))}static fromPartialSignatures(e,t){return new Signature(Crypto.combinePartialSignatures(e._obj,t.map(e=>e._obj)))}static unserialize(e){return new Signature(Crypto.signatureUnserialize(e.read(Crypto.signatureSize)))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(Crypto.signatureSerialize(this._obj)),e}get serializedSize(){return Crypto.signatureSize}verify(e,t){return Crypto.signatureVerify(e._obj,t,this._obj)}equals(e){return e instanceof Signature&&super.equals(e)}}Class.register(Signature);class Address extends Primitive{static copy(e){if(!e)return e;const t=new Uint8Array(e._obj);return new Address(t)}static fromHash(e){return new Address(e.subarray(0,Address.SERIALIZED_SIZE))}constructor(e){super(e,Uint8Array,Address.SERIALIZED_SIZE)}static unserialize(e){return new Address(e.read(Address.SERIALIZED_SIZE))}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).write(this._obj),e}subarray(e,t){return this._obj.subarray(e,t)}get serializedSize(){return Address.SERIALIZED_SIZE}equals(e){return e instanceof Address&&super.equals(e)}static fromString(e){try{return Address.fromUserFriendlyAddress(e)}catch(e){}try{return Address.fromHex(e)}catch(e){}try{return Address.fromBase64(e)}catch(e){}throw new Error("Invalid address format")}static fromBase64(e){return new Address(BufferUtils.fromBase64(e))}static fromHex(e){return new Address(BufferUtils.fromHex(e))}static fromUserFriendlyAddress(e){if((e=e.replace(/ /g,"")).substr(0,2).toUpperCase()!==Address.CCODE)throw new Error("Invalid Address: Wrong country code");if(36!==e.length)throw new Error("Invalid Address: Should be 36 chars (ignoring spaces)");if(1!==Address._ibanCheck(e.substr(4)+e.substr(0,4)))throw new Error("Invalid Address: Checksum invalid");return new Address(BufferUtils.fromBase32(e.substr(4)))}static _ibanCheck(e){const t=e.split("").map(e=>{const t=e.toUpperCase().charCodeAt(0);return t>=48&&t<=57?e:(t-55).toString()}).join("");let r="";for(let e=0;e<Math.ceil(t.length/6);e++)r=(parseInt(r+t.substr(6*e,6))%97).toString();return parseInt(r)}toUserFriendlyAddress(e=!0){const t=BufferUtils.toBase32(this.serialize()),r=("00"+(98-Address._ibanCheck(t+Address.CCODE+"00"))).slice(-2);let i=Address.CCODE+r+t;return e&&(i=i.replace(/.{4}/g,"$& ").trim()),i}}Address.CCODE="NQ",Address.SERIALIZED_SIZE=20,Address.HEX_SIZE=40,Address.NULL=new Address(new Uint8Array(Address.SERIALIZED_SIZE)),Address.CONTRACT_CREATION=new Address(new Uint8Array(Address.SERIALIZED_SIZE)),Class.register(Address);class Account{constructor(e,t){if(!NumberUtils.isUint8(e))throw new Error("Malformed type");if(!NumberUtils.isUint64(t))throw new Error("Malformed balance");this._type=e,this._balance=t}static unserialize(e){const t=e.readUint8();if(e.readPos--,!Account.TYPE_MAP.has(t))throw new Error("Unknown account type");return Account.TYPE_MAP.get(t).unserialize(e)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._type),e.writeUint64(this._balance),e}get serializedSize(){return 9}equals(e){return BufferUtils.equals(this.serialize(),e.serialize())}toString(){return`Account{type=${this._type}, balance=${this._balance.toString()}`}get balance(){return this._balance}get type(){return this._type}withBalance(e){throw new Error("Not yet implemented.")}withOutgoingTransaction(e,t,r,i=!1){if(i){if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");return this.withBalance(this._balance+e.value+e.fee)}{const i=this._balance-e.value-e.fee;if(i<0)throw new Error("Balance Error!");if(t<e.validityStartHeight||t>=e.validityStartHeight+Policy.TRANSACTION_VALIDITY_WINDOW)throw new Error("Validity Error!");if(r.containsTransaction(e))throw new Error("Double Transaction Error!");return this.withBalance(i)}}withIncomingTransaction(e,t,r=!1){if(r){const t=this._balance-e.value;if(t<0)throw new Error("Balance Error!");return this.withBalance(t)}return this.withBalance(this._balance+e.value)}withContractCommand(e,t,r=!1){throw new Error("Not yet implemented")}isInitial(){return this===Account.INITIAL}isToBePruned(){return 0===this._balance&&!this.isInitial()}}Account.Type={BASIC:0,VESTING:1,HTLC:2},Account.TYPE_MAP=new Map,Class.register(Account);class PrunedAccount{constructor(e,t){if(!(e instanceof Address))throw new Error("Malformed address");this._address=e,this._account=t}static unserialize(e){return new PrunedAccount(Address.unserialize(e),Account.unserialize(e))}compare(e){return this._address.compare(e._address)}get address(){return this._address}get account(){return this._account}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._address.serialize(e),this._account.serialize(e),this}get serializedSize(){return this._address.serializedSize+this._account.serializedSize}}Class.register(PrunedAccount);class BasicAccount extends Account{static copy(e){return e?new BasicAccount(e._balance):e}constructor(e=0){super(Account.Type.BASIC,e)}static unserialize(e){if(e.readUint8()!==Account.Type.BASIC)throw new Error("Invalid account type");const t=e.readUint64();return new BasicAccount(t)}equals(e){return e instanceof BasicAccount&&this._type===e._type&&this._balance===e._balance}toString(){return`BasicAccount{balance=${this._balance}}`}static verifyOutgoingTransaction(e){return SignatureProof.verifyTransaction(e)}static verifyIncomingTransaction(e){return!(e.data.byteLength>64)}withBalance(e){return new BasicAccount(e)}withIncomingTransaction(e,t,r=!1){if(!r){if(e.hasFlag(Transaction.Flag.CONTRACT_CREATION)!==(e.recipientType!==this._type))throw new Error("Data Error!")}return super.withIncomingTransaction(e,t,r)}withContractCommand(e,t,r=!1){return!r&&e.recipientType!==this._type&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION)?Account.TYPE_MAP.get(e.recipientType).create(this._balance,t,e):this}isInitial(){return 0===this._balance}}Account.INITIAL=new BasicAccount(0),Account.TYPE_MAP.set(Account.Type.BASIC,BasicAccount),Class.register(BasicAccount);class Contract extends Account{constructor(e,t){super(e,t)}static verifyIncomingTransaction(e){return!!e.recipient.equals(e.getContractCreationAddress())}withIncomingTransaction(e,t,r=!1){if(!r&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION))throw new Error("Data error");return super.withIncomingTransaction(e,t,r)}withContractCommand(e,t,r=!1){return r&&e.hasFlag(Transaction.Flag.CONTRACT_CREATION)?new BasicAccount(this.balance):this}}Class.register(Contract);class HashedTimeLockedContract extends Contract{constructor(e=0,t=Address.NULL,r=Address.NULL,i=Hash.NULL,s=1,n=0,o=e){if(super(Account.Type.HTLC,e),!(t instanceof Address))throw new Error("Malformed address");if(!(r instanceof Address))throw new Error("Malformed address");if(!(i instanceof Hash))throw new Error("Malformed address");if(!NumberUtils.isUint8(s)||0===s)throw new Error("Malformed hashCount");if(!NumberUtils.isUint32(n))throw new Error("Malformed timeout");if(!NumberUtils.isUint64(o))throw new Error("Malformed totalAmount");this._sender=t,this._recipient=r,this._hashRoot=i,this._hashCount=s,this._timeout=n,this._totalAmount=o}static create(e,t,r){const i=new SerialBuffer(r.data),s=Address.unserialize(i),n=Address.unserialize(i),o=i.readUint8(),a=Hash.unserialize(i,o),l=i.readUint8(),c=i.readUint32();return new HashedTimeLockedContract(e,s,n,a,l,c)}static unserialize(e){if(e.readUint8()!==Account.Type.HTLC)throw new Error("Invalid account type");const t=e.readUint64(),r=Address.unserialize(e),i=Address.unserialize(e),s=e.readUint8(),n=Hash.unserialize(e,s),o=e.readUint8(),a=e.readUint32(),l=e.readUint64();return new HashedTimeLockedContract(t,r,i,n,o,a,l)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),super.serialize(e),this._sender.serialize(e),this._recipient.serialize(e),e.writeUint8(this._hashRoot.algorithm),this._hashRoot.serialize(e),e.writeUint8(this._hashCount),e.writeUint32(this._timeout),e.writeUint64(this._totalAmount),e}get serializedSize(){return super.serializedSize+this._sender.serializedSize+this._recipient.serializedSize+1+this._hashRoot.serializedSize+1+4+8}get sender(){return this._sender}get recipient(){return this._recipient}get hashRoot(){return this._hashRoot}get hashCount(){return this._hashCount}get timeout(){return this._timeout}get totalAmount(){return this._totalAmount}toString(){return`HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(!1)}, recipient=${this._sender.toUserFriendlyAddress(!1)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`}equals(e){return e instanceof HashedTimeLockedContract&&this._type===e._type&&this._balance===e._balance&&this._sender.equals(e._sender)&&this._recipient.equals(e._recipient)&&this._hashRoot.equals(e._hashRoot)&&this._hashCount===e._hashCount&&this._timeout===e._timeout&&this._totalAmount===e._totalAmount}static verifyOutgoingTransaction(e){try{const t=new SerialBuffer(e.proof);switch(t.readUint8()){case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER:{const r=t.readUint8(),i=t.readUint8(),s=Hash.unserialize(t,r);let n=Hash.unserialize(t,r);for(let e=0;e<i;++e)n=Hash.compute(n.array,r);if(!s.equals(n))return!1;if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break}case HashedTimeLockedContract.ProofType.EARLY_RESOLVE:if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break;case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:if(!SignatureProof.unserialize(t).verify(null,e.serializeContent()))return!1;break;default:return!1}return t.readPos===t.byteLength}catch(e){return!1}}static verifyIncomingTransaction(e){try{const t=new SerialBuffer(e.data);Address.unserialize(t),Address.unserialize(t);const r=t.readUint8();return Hash.unserialize(t,r),t.readUint8(),t.readUint32(),r!==Hash.Algorithm.ARGON2D&&(t.readPos===t.byteLength&&Contract.verifyIncomingTransaction(e))}catch(e){return!1}}withBalance(e){return new HashedTimeLockedContract(e,this._sender,this._recipient,this._hashRoot,this._hashCount,this._timeout,this._totalAmount)}withOutgoingTransaction(e,t,r,i=!1){const s=new SerialBuffer(e.proof);let n=0;switch(s.readUint8()){case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER:{if(this._timeout<t)throw new Error("Proof Error!");const e=s.readUint8(),r=s.readUint8();if(!Hash.unserialize(s,e).equals(this._hashRoot))throw new Error("Proof Error!");if(Hash.unserialize(s,e),!SignatureProof.unserialize(s).isSignedBy(this._recipient))throw new Error("Proof Error!");n=Math.max(0,Math.floor((1-r/this._hashCount)*this._totalAmount));break}case HashedTimeLockedContract.ProofType.EARLY_RESOLVE:if(!SignatureProof.unserialize(s).isSignedBy(this._recipient))throw new Error("Proof Error!");if(!SignatureProof.unserialize(s).isSignedBy(this._sender))throw new Error("Proof Error!");break;case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:if(this._timeout>=t)throw new Error("Proof Error!");if(!SignatureProof.unserialize(s).isSignedBy(this._sender))throw new Error("Proof Error!");break;default:throw new Error("Proof Error!")}if(!i){if(this._balance-e.value-e.fee<n)throw new Error("Balance Error!")}return super.withOutgoingTransaction(e,t,r,i)}withIncomingTransaction(e,t,r=!1){throw new Error("Illegal incoming transaction")}}HashedTimeLockedContract.ProofType={REGULAR_TRANSFER:1,EARLY_RESOLVE:2,TIMEOUT_RESOLVE:3},Account.TYPE_MAP.set(Account.Type.HTLC,HashedTimeLockedContract),Class.register(HashedTimeLockedContract);class VestingContract extends Contract{constructor(e=0,t=Address.NULL,r=0,i=0,s=e,n=e){if(super(Account.Type.VESTING,e),!(t instanceof Address))throw new Error("Malformed address");if(!NumberUtils.isUint32(r))throw new Error("Malformed vestingStart");if(!NumberUtils.isUint32(i))throw new Error("Malformed vestingStepBlocks");if(!NumberUtils.isUint64(s))throw new Error("Malformed vestingStepAmount");if(!NumberUtils.isUint64(n))throw new Error("Malformed lowerCap");this._owner=t,this._vestingStart=r,this._vestingStepBlocks=i,this._vestingStepAmount=s,this._vestingTotalAmount=n}static create(e,t,r){let i,s,n,o;const a=new SerialBuffer(r.data),l=Address.unserialize(a);switch(o=r.value,r.data.length){case Address.SERIALIZED_SIZE+4:i=0,s=a.readUint32(),n=o;break;case Address.SERIALIZED_SIZE+16:i=a.readUint32(),s=a.readUint32(),n=a.readUint64();break;case Address.SERIALIZED_SIZE+24:i=a.readUint32(),s=a.readUint32(),n=a.readUint64(),o=a.readUint64();break;default:throw new Error("Invalid transaction data")}return new VestingContract(e,l,i,s,n,o)}static unserialize(e){if(e.readUint8()!==Account.Type.VESTING)throw new Error("Invalid account type");const t=e.readUint64(),r=Address.unserialize(e),i=e.readUint32(),s=e.readUint32(),n=e.readUint64(),o=e.readUint64();return new VestingContract(t,r,i,s,n,o)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),super.serialize(e),this._owner.serialize(e),e.writeUint32(this._vestingStart),e.writeUint32(this._vestingStepBlocks),e.writeUint64(this._vestingStepAmount),e.writeUint64(this._vestingTotalAmount),e}get serializedSize(){return super.serializedSize+this._owner.serializedSize+4+4+8+8}get owner(){return this._owner}get vestingStart(){return this._vestingStart}get vestingStepBlocks(){return this._vestingStepBlocks}get vestingStepAmount(){return this._vestingStepAmount}get vestingTotalAmount(){return this._vestingTotalAmount}toString(){return`VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`}equals(e){return e instanceof VestingContract&&this._type===e._type&&this._balance===e._balance&&this._owner.equals(e._owner)&&this._vestingStart===e._vestingStart&&this._vestingStepBlocks===e._vestingStepBlocks&&this._vestingStepAmount===e._vestingStepAmount&&this._vestingTotalAmount===e._vestingTotalAmount}static verifyOutgoingTransaction(e){const t=new SerialBuffer(e.proof);return!!SignatureProof.unserialize(t).verify(null,e.serializeContent())&&t.readPos===t.byteLength}static verifyIncomingTransaction(e){switch(e.data.length){case Address.SERIALIZED_SIZE+4:case Address.SERIALIZED_SIZE+16:case Address.SERIALIZED_SIZE+24:return Contract.verifyIncomingTransaction(e);default:return!1}}withBalance(e){return new VestingContract(e,this._owner,this._vestingStart,this._vestingStepBlocks,this._vestingStepAmount,this._vestingTotalAmount)}withOutgoingTransaction(e,t,r,i=!1){if(!i){const r=this.getMinCap(t);if(this._balance-e.value-e.fee<r)throw new Error("Balance Error!");const i=new SerialBuffer(e.proof);if(!SignatureProof.unserialize(i).isSignedBy(this._owner))throw new Error("Proof Error!")}return super.withOutgoingTransaction(e,t,r,i)}withIncomingTransaction(e,t,r=!1){throw new Error("Illegal incoming transaction")}getMinCap(e){return this._vestingStepBlocks&&this._vestingStepAmount>0?Math.max(0,this._vestingTotalAmount-Math.floor((e-this._vestingStart)/this._vestingStepBlocks)*this._vestingStepAmount):0}}Account.TYPE_MAP.set(Account.Type.VESTING,VestingContract),Class.register(VestingContract);class BlockHeader{static copy(e){if(!e)return e;const t=Hash.copy(e._prevHash),r=Hash.copy(e._interlinkHash),i=Hash.copy(e._bodyHash),s=Hash.copy(e._accountsHash);return new BlockHeader(t,r,i,s,e._nBits,e._height,e._timestamp,e._nonce,e._version)}constructor(e,t,r,i,s,n,o,a,l=BlockHeader.CURRENT_VERSION){if(!NumberUtils.isUint16(l))throw"Malformed version";if(!Hash.isHash(e))throw"Malformed prevHash";if(!Hash.isHash(t))throw"Malformed interlinkHash";if(!Hash.isHash(r))throw"Malformed bodyHash";if(!Hash.isHash(i))throw"Malformed accountsHash";if(!NumberUtils.isUint32(s)||!BlockUtils.isValidCompact(s))throw"Malformed nBits";if(!NumberUtils.isUint32(n))throw"Invalid height";if(!NumberUtils.isUint32(o))throw"Malformed timestamp";if(!NumberUtils.isUint32(a))throw"Malformed nonce";this._version=l,this._prevHash=e,this._interlinkHash=t,this._bodyHash=r,this._accountsHash=i,this._nBits=s,this._height=n,this._timestamp=o,this._nonce=a}static unserialize(e){const t=e.readUint16();if(!BlockHeader.SUPPORTED_VERSIONS.includes(t))throw new Error(`Unsupported block version ${t}`);const r=Hash.unserialize(e),i=Hash.unserialize(e),s=Hash.unserialize(e),n=Hash.unserialize(e),o=e.readUint32(),a=e.readUint32(),l=e.readUint32(),c=e.readUint32();return new BlockHeader(r,i,s,n,o,a,l,c,t)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint16(this._version),this._prevHash.serialize(e),this._interlinkHash.serialize(e),this._bodyHash.serialize(e),this._accountsHash.serialize(e),e.writeUint32(this._nBits),e.writeUint32(this._height),e.writeUint32(this._timestamp),e.writeUint32(this._nonce),e}get serializedSize(){return 2+this._prevHash.serializedSize+this._interlinkHash.serializedSize+this._bodyHash.serializedSize+this._accountsHash.serializedSize+4+4+4+4}async verifyProofOfWork(e){const t=await this.pow(e);return BlockUtils.isProofOfWork(t,this.target)}isImmediateSuccessorOf(e){if(this.height!==e.height+1)return!1;if(this.timestamp<e.timestamp)return!1;const t=e.hash();return!!this.prevHash.equals(t)}hash(e){return this._hash=this._hash||Hash.light(this.serialize(e)),this._hash}async hashAsync(e){return this._hash=this._hash||await Hash.lightAsync(this.serialize(e)),this._hash}async pow(e){return this._pow=this._pow||await Hash.hard(this.serialize(e)),this._pow}equals(e){return e instanceof BlockHeader&&this._prevHash.equals(e.prevHash)&&this._interlinkHash.equals(e.interlinkHash)&&this._bodyHash.equals(e.bodyHash)&&this._accountsHash.equals(e.accountsHash)&&this._nBits===e.nBits&&this._height===e.height&&this._timestamp===e.timestamp&&this._nonce===e.nonce}toString(){return"BlockHeader{"+`prevHash=${this._prevHash}, `+`interlinkHash=${this._interlinkHash}, `+`bodyHash=${this._bodyHash}, `+`accountsHash=${this._accountsHash}, `+`nBits=${this._nBits.toString(16)}, `+`height=${this._height}, `+`timestamp=${this._timestamp}, `+`nonce=${this._nonce}`+"}"}get version(){return this._version}get prevHash(){return this._prevHash}get interlinkHash(){return this._interlinkHash}get bodyHash(){return this._bodyHash}get accountsHash(){return this._accountsHash}get nBits(){return this._nBits}get target(){return BlockUtils.compactToTarget(this._nBits)}get difficulty(){return BlockUtils.compactToDifficulty(this._nBits)}get height(){return this._height}get timestamp(){return this._timestamp}get nonce(){return this._nonce}set nonce(e){this._nonce=e,this._hash=null,this._pow=null}}BlockHeader.Version={V1:1},BlockHeader.CURRENT_VERSION=BlockHeader.Version.V1,BlockHeader.SUPPORTED_VERSIONS=[BlockHeader.Version.V1],BlockHeader.SERIALIZED_SIZE=146,Class.register(BlockHeader);class BlockInterlink{static copy(e){if(!e)return e;const t=e._hashes.map(e=>Hash.copy(e)),r=new Uint8Array(e._repeatBits),i=e._compressed.map(e=>Hash.copy(e));return new BlockInterlink(t,void 0,r,i)}static _compress(e,t){const r=e.length,i=Math.ceil(r/8),s=new Uint8Array(i);let n=t;const o=[];for(let t=0;t<r;t++){const r=e[t];r.equals(n)?s[Math.floor(t/8)]|=128>>>t%8:(o.push(r),n=r)}return{repeatBits:s,compressed:o}}constructor(e,t,r,i){if(!Array.isArray(e)||!NumberUtils.isUint8(e.length)||e.some(e=>!(e instanceof Hash)))throw new Error("Malformed hashes");if((r||i)&&(!r||!i))throw new Error("Malformed repeatBits/compressed");if(!t&&!r)throw new Error("Either prevHash or repeatBits/compressed required");r||({repeatBits:r,compressed:i}=BlockInterlink._compress(e,t)),this._hashes=e,this._repeatBits=r,this._compressed=i}static unserialize(e,t){const r=e.readUint8(),i=Math.ceil(r/8),s=e.read(i);let n=t;const o=[],a=[];for(let t=0;t<r;t++){0!=(s[Math.floor(t/8)]&128>>>t%8)||(n=Hash.unserialize(e),a.push(n)),o.push(n)}return new BlockInterlink(o,t,s,a)}serialize(e){(e=e||new SerialBuffer(this.serializedSize)).writeUint8(this._hashes.length),e.write(this._repeatBits);for(const t of this._compressed)t.serialize(e);return e}get serializedSize(){return 1+this._repeatBits.length+this._compressed.reduce((e,t)=>e+t.serializedSize,0)}equals(e){return e instanceof BlockInterlink&&this._hashes.length===e._hashes.length&&this._hashes.every((t,r)=>t.equals(e.hashes[r]))}hash(){return this._hash||(this._hash=MerkleTree.computeRoot([this._repeatBits,Block.GENESIS.HASH,...this._compressed])),this._hash}get hashes(){return this._hashes}get length(){return this._hashes.length}}Class.register(BlockInterlink);class BlockBody{static getMetadataSize(e){return Address.SERIALIZED_SIZE+1+e.byteLength+2}constructor(e,t,r=new Uint8Array(0),i=[]){if(!(e instanceof Address))throw"Malformed minerAddr";if(!Array.isArray(t)||t.some(e=>!(e instanceof Transaction)))throw"Malformed transactions";if(!(r instanceof Uint8Array&&NumberUtils.isUint8(r.byteLength)))throw"Malformed extraData";this._minerAddr=e,this._extraData=r,this._transactions=t,this._prunedAccounts=i,this._hash=null}static unserialize(e){const t=Address.unserialize(e),r=e.readUint8(),i=e.read(r),s=e.readUint16(),n=new Array(s);for(let t=0;t<s;t++)n[t]=Transaction.unserialize(e);const o=e.readUint16(),a=[];for(let t=0;t<o;t++)a.push(PrunedAccount.unserialize(e));return new BlockBody(t,n,i,a)}serialize(e){e=e||new SerialBuffer(this.serializedSize),this._minerAddr.serialize(e),e.writeUint8(this._extraData.byteLength),e.write(this._extraData),e.writeUint16(this._transactions.length);for(const t of this._transactions)t.serialize(e);e.writeUint16(this._prunedAccounts.length);for(const t of this._prunedAccounts)t.serialize(e);return e}get serializedSize(){let e=this._minerAddr.serializedSize+1+this._extraData.byteLength+2+2;for(const t of this._transactions)e+=t.serializedSize;return e+=this._prunedAccounts.reduce((e,t)=>e+t.serializedSize,0)}verify(){let e=null;for(const t of this._transactions){if(e&&e.compareBlockOrder(t)>=0)return Log.w(BlockBody,"Invalid block - transactions not ordered."),!1;if(e=t,!t.verify())return Log.w(BlockBody,"Invalid block - invalid transaction"),!1}let t=null;for(const e of this._prunedAccounts){if(t&&t.compare(e)>=0)return Log.w(BlockBody,"Invalid block - pruned accounts not ordered."),!1;if(t=e,!e.account.isToBePruned())return Log.w(BlockBody,"Invalid block - invalid pruned account"),!1}return!0}getMerkleLeafs(){return[this._minerAddr,this._extraData,...this._transactions,...this.prunedAccounts]}hash(){return this._hash||(this._hash=MerkleTree.computeRoot(this.getMerkleLeafs())),this._hash}equals(e){return e instanceof BlockBody&&this._minerAddr.equals(e.minerAddr)&&BufferUtils.equals(this._extraData,e.extraData)&&this._transactions.length===e.transactions.length&&this._transactions.every((t,r)=>t.equals(e.transactions[r]))}getAddresses(){const e=[this._minerAddr];for(const t of this._transactions)e.push(t.sender,t.recipient);return e}get extraData(){return this._extraData}get minerAddr(){return this._minerAddr}get transactions(){return this._transactions}get transactionCount(){return this._transactions.length}get prunedAccounts(){return this._prunedAccounts}}Class.register(BlockBody);class BlockUtils{static compactToTarget(e){return(16777215&e)*Math.pow(2,8*((e>>24)-3))}static targetToCompact(e){if(!Number.isFinite(e)||Number.isNaN(e))throw"Invalid Target";let t=Math.max(Math.ceil(Math.log2(e)/8),1);return e/Math.pow(2,8*(t-1))>=128&&t++,(t<<24)+(e/Math.pow(2,8*(t-3))&16777215)}static getTargetHeight(e){return Math.ceil(Math.log2(e))}static getTargetDepth(e){return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX)-BlockUtils.getTargetHeight(e)}static compactToDifficulty(e){return Policy.BLOCK_TARGET_MAX/BlockUtils.compactToTarget(e)}static difficultyToCompact(e){return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(e))}static difficultyToTarget(e){return Policy.BLOCK_TARGET_MAX/e}static targetToDifficulty(e){return Policy.BLOCK_TARGET_MAX/e}static hashToTarget(e){return parseInt(e.toHex(),16)}static realDifficulty(e){return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(e))}static isProofOfWork(e,t){return parseInt(e.toHex(),16)<=t}static isValidCompact(e){return BlockUtils.isValidTarget(BlockUtils.compactToTarget(e))}static isValidTarget(e){return e>=1&&e<=Policy.BLOCK_TARGET_MAX}static getNextTarget(e,t,r){Assert.that(e.height-t.height===Policy.DIFFICULTY_BLOCK_WINDOW||e.height<=Policy.DIFFICULTY_BLOCK_WINDOW&&1===t.height,`Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);let i=e.timestamp-t.timestamp;e.height<=Policy.DIFFICULTY_BLOCK_WINDOW&&(i+=(Policy.DIFFICULTY_BLOCK_WINDOW-e.height+1)*Policy.BLOCK_TIME,r+=Policy.DIFFICULTY_BLOCK_WINDOW-e.height+1);let s=i/(Policy.DIFFICULTY_BLOCK_WINDOW*Policy.BLOCK_TIME);s=Math.max(s,1/Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR),s=Math.min(s,Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);const n=r/Policy.DIFFICULTY_BLOCK_WINDOW;let o=BlockUtils.difficultyToTarget(n)*s;return o=Math.min(o,Policy.BLOCK_TARGET_MAX),o=Math.max(o,1)}}Class.register(BlockUtils);class Block{static copy(e){return e?new Block(BlockHeader.copy(e._header),BlockInterlink.copy(e._interlink),BlockBody.copy(e._body)):e}constructor(e,t,r){if(!(e instanceof BlockHeader))throw"Malformed header";if(!(t instanceof BlockInterlink))throw"Malformed interlink";if(r&&!(r instanceof BlockBody))throw"Malformed body";this._header=e,this._interlink=t,this._body=r}static unserialize(e){const t=BlockHeader.unserialize(e),r=BlockInterlink.unserialize(e,t.prevHash);let i=void 0;return e.readUint8()&&(i=BlockBody.unserialize(e)),new Block(t,r,i)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._header.serialize(e),this._interlink.serialize(e),this._body?(e.writeUint8(1),this._body.serialize(e)):e.writeUint8(0),e}get serializedSize(){return this._header.serializedSize+this._interlink.serializedSize+1+(this._body?this._body.serializedSize:0)}async verify(e){if(void 0===this._valid)if(this.isLight()||this.body.transactions.length<150||!IWorker.areWorkersAsync)this._valid=await this.computeVerify(e.now());else{const{valid:t,pow:r,interlinkHash:i,bodyHash:s}=await Crypto.blockVerify(this.serialize(),e.now());this._valid=t,this.header._pow=Hash.unserialize(new SerialBuffer(r)),this.interlink._hash=Hash.unserialize(new SerialBuffer(i)),this.body._hash=Hash.unserialize(new SerialBuffer(s))}return this._valid}async computeVerify(e){return 1e3*this._header.timestamp>e+1e3*Block.TIMESTAMP_DRIFT_MAX?(Log.w(Block,"Invalid block - timestamp too far in the future"),!1):await this._header.verifyProofOfWork()?this.serializedSize>Policy.BLOCK_SIZE_MAX?(Log.w(Block,"Invalid block - max block size exceeded"),!1):!!this._verifyInterlink()&&!(this.isFull()&&!this._verifyBody()):(Log.w(Block,"Invalid block - PoW verification failed"),!1)}_verifyInterlink(){if(1===this.height&&this._header.interlinkHash.equals(new Hash(null)))return!0;const e=this._interlink.hash();return!!this._header.interlinkHash.equals(e)||(Log.w(Block,"Invalid block - interlink hash mismatch"),!1)}_verifyBody(){if(!this._body.verify())return!1;const e=this._body.hash();return!!this._header.bodyHash.equals(e)||(Log.w(Block,"Invalid block - body hash mismatch"),!1)}async isImmediateSuccessorOf(e){if(!this._header.isImmediateSuccessorOf(e.header))return!1;const t=await e.getNextInterlink(this.target,this.version);return!!this._interlink.equals(t)}async isInterlinkSuccessorOf(e){if(this._header.height<=e.header.height)return Log.v(Block,"No interlink successor - height"),!1;if(this._header.timestamp<e.header.timestamp)return Log.v(Block,"No interlink successor - timestamp"),!1;const t=e.hash();if(!Block.GENESIS.HASH.equals(t)){const r=await e.pow(),i=BlockUtils.getTargetHeight(this.target);let s=!1,n=0;for(;n<this._interlink.length;n++)if(t.equals(this._interlink.hashes[n])&&(s=!0,!BlockUtils.isProofOfWork(r,Math.pow(2,i-n))))return Log.v(Block,"No interlink successor - invalid position in interlink"),!1;if(!s)return Log.v(Block,"No interlink successor - not in interlink"),!1}if(this._header.prevHash.equals(t)){if(this._header.height!==e.header.height+1)return Log.v(Block,"No interlink successor - immediate height"),!1;const t=(await e.getNextInterlink(this.target,this.version)).hash();if(!this._header.interlinkHash.equals(t))return Log.v(Block,"No interlink successor - immediate interlink"),!1}else{if(this._header.height===e.height.height+1)return Log.v(Block,"No interlink successor - immediate height (2)"),!1;{const t=new HashSet;if(t.addAll(this._interlink.hashes),t.removeAll(e.interlink.hashes),t.length>this._header.height-e.header.height)return Log.v(Block,"No interlink successor - too many new blocks"),!1;const r=BlockUtils.getTargetDepth(this.target)-BlockUtils.getTargetDepth(e.target);if(this._interlink.length<e.interlink.length-r)return Log.v(Block,"No interlink successor - interlink too short"),!1;let i=!1;const s=this._interlink.hashes,n=e.interlink.hashes;for(let e=1;e<n.length&&e-r<s.length;e++)if(n[e].equals(s[e-r]))i=!0;else if(i)return Log.v(Block,"No interlink successor - invalid common suffix"),!1}}return!0}async isSuccessorOf(e){return await this.isImmediateSuccessorOf(e)||await this.isInterlinkSuccessorOf(e)}async getNextInterlink(e,t=BlockHeader.CURRENT_VERSION){const r=await this.pow(),i=BlockUtils.getTargetDepth(BlockUtils.hashToTarget(r)),s=BlockUtils.getTargetDepth(e);let n=i-s;const o=[],a=this.hash();for(let e=0;e<=n;e++)o.push(a);for(let e=n+(s-BlockUtils.getTargetDepth(this.target))+1;e<this.interlink.length;e++)o.push(this.interlink.hashes[e]);return new BlockInterlink(o,a)}equals(e){return e instanceof Block&&this._header.equals(e._header)&&this._interlink.equals(e._interlink)&&(this._body?this._body.equals(e._body):!e._body)}isLight(){return!this._body}isFull(){return!!this._body}toLight(){return this.isLight()?this:new Block(this._header,this._interlink)}toFull(e){return this.isFull()?this:new Block(this._header,this._interlink,e)}get header(){return this._header}get interlink(){return this._interlink}get body(){if(this.isLight())throw"Cannot access body of light block";return this._body}get version(){return this._header.version}get prevHash(){return this._header.prevHash}get bodyHash(){return this._header.bodyHash}get accountsHash(){return this._header.accountsHash}get nBits(){return this._header.nBits}get target(){return this._header.target}get difficulty(){return this._header.difficulty}get height(){return this._header.height}get timestamp(){return this._header.timestamp}get nonce(){return this._header.nonce}get minerAddr(){return this._body.minerAddr}get transactions(){return this._body.transactions}get transactionCount(){return this._body.transactionCount}hash(e){return this._header.hash(e)}hashAsync(e){return this._header.hashAsync(e)}pow(e){return this._header.pow(e)}}Block.TIMESTAMP_DRIFT_MAX=600,Class.register(Block),Block.GENESIS=new Block(new BlockHeader(new Hash(null),new Hash(null),Hash.fromBase64("z2Qp5kzePlvq/ABN31K1eUAQ5Dn8rpeZQU0PTQn9pH0="),Hash.fromBase64("jIdIsQkjXmPKtb0RM6sYZ6Tfq/Y7DPxEirBKYOhtH7k="),BlockUtils.difficultyToCompact(1),1,0,313530,BlockHeader.Version.V1),new BlockInterlink([],new Hash(null)),new BlockBody(Address.fromBase64("9KzhefhVmhN0pOSnzcIYnlVOTs0="),[])),Block.GENESIS.HASH=Hash.fromBase64("90SfoDkkc0+taLwtyuEM/Q2J4jvN24xmVnMr7ywaT4k=");class Transaction{constructor(e,t,r,i,s,n,o,a,l,c,h){if(!(t instanceof Address))throw new Error("Malformed sender");if(!NumberUtils.isUint8(r))throw new Error("Malformed sender type");if(!(i instanceof Address))throw new Error("Malformed recipient");if(!NumberUtils.isUint8(s))throw new Error("Malformed recipient type");if(!NumberUtils.isUint64(n)||0===n)throw new Error("Malformed value");if(!NumberUtils.isUint64(o))throw new Error("Malformed fee");if(!NumberUtils.isUint32(a))throw new Error("Malformed validityStartHeight");if(!NumberUtils.isUint8(l)&&(l&~Transaction.Flag.ALL)>0)throw new Error("Malformed flags");if(!(c instanceof Uint8Array&&NumberUtils.isUint16(c.byteLength)))throw new Error("Malformed data");if(h&&(!(h instanceof Uint8Array)||!NumberUtils.isUint16(h.byteLength)))throw new Error("Malformed proof");this._format=e,this._sender=t,this._senderType=r,this._recipient=i,this._recipientType=s,this._value=n,this._fee=o,this._validityStartHeight=a,this._flags=l,this._data=c,this._proof=h,this._recipient===Address.CONTRACT_CREATION&&(this._recipient=this.getContractCreationAddress())}static unserialize(e){const t=e.readUint8();if(e.readPos--,!Transaction.FORMAT_MAP.has(t))throw new Error("Invalid transaction type");return Transaction.FORMAT_MAP.get(t).unserialize(e)}serializeContent(e){return(e=e||new SerialBuffer(this.serializedContentSize)).writeUint16(this._data.byteLength),e.write(this._data),this._sender.serialize(e),e.writeUint8(this._senderType),this._recipient.serialize(e),e.writeUint8(this._recipientType),e.writeUint64(this._value),e.writeUint64(this._fee),e.writeUint32(this._validityStartHeight),e.writeUint8(this._flags),e}get serializedContentSize(){return 2+this._data.byteLength+this._sender.serializedSize+1+this._recipient.serializedSize+1+8+8+4+1}verify(){return this._recipient.equals(this._sender)?(Log.w(Transaction,"Sender and recipient must not match",this),!1):Account.TYPE_MAP.has(this._senderType)&&Account.TYPE_MAP.has(this._recipientType)?Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)?!!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)||(Log.w(Transaction,"Invalid for recipient",this),!1):(Log.w(Transaction,"Invalid for sender",this),!1):(Log.w(Transaction,"Invalid account type",this),!1)}get serializedSize(){throw new Error("Getter needs to be overwritten by subclasses")}serialize(e){throw new Error("Method needs to be overwritten by subclasses")}hash(){return this._hash=this._hash||Hash.light(this.serializeContent()),this._hash}async hashAsync(){return this._hash=this._hash||await Hash.lightAsync(this.serializeContent()),this._hash}compare(e){return this.fee/this.serializedSize>e.fee/e.serializedSize?-1:this.fee/this.serializedSize<e.fee/e.serializedSize?1:this.serializedSize>e.serializedSize?-1:this.serializedSize<e.serializedSize?1:this.fee>e.fee?-1:this.fee<e.fee?1:this.value>e.value?-1:this.value<e.value?1:this.compareBlockOrder(e)}compareBlockOrder(e){const t=this._recipient.compare(e._recipient);if(0!==t)return t;if(this._validityStartHeight<e._validityStartHeight)return-1;if(this._validityStartHeight>e._validityStartHeight)return 1;if(this._fee>e._fee)return-1;if(this._fee<e._fee)return 1;if(this._value>e._value)return-1;if(this._value<e._value)return 1;const r=this._sender.compare(e._sender);return 0!==r?r:this._recipientType<e._recipientType?-1:this._recipientType>e._recipientType?1:this._senderType<e._senderType?-1:this._senderType>e._senderType?1:this._flags<e._flags?-1:this._flags>e._flags?1:BufferUtils.compare(this._data,e._data)}equals(e){return e instanceof Transaction&&this._sender.equals(e._sender)&&this._senderType===e._senderType&&this._recipient.equals(e._recipient)&&this._recipientType===e._recipientType&&this._value===e._value&&this._fee===e._fee&&this._validityStartHeight===e._validityStartHeight&&this._flags===e._flags&&BufferUtils.equals(this._data,e._data)}toString(){return"Transaction{"+`sender=${this._sender.toBase64()}, `+`recipient=${this._recipient.toBase64()}, `+`value=${this._value}, `+`fee=${this._fee}, `+`validityStartHeight=${this._validityStartHeight}`+"}"}getContractCreationAddress(){const e=Transaction.unserialize(this.serialize());return e._recipient=Address.NULL,e._hash=null,Address.fromHash(e.hash())}get sender(){return this._sender}get senderType(){return this._senderType}get recipient(){return this._recipient}get recipientType(){return this._recipientType}get value(){return this._value}get fee(){return this._fee}get feePerByte(){return this._fee/this.serializedSize}get validityStartHeight(){return this._validityStartHeight}get flags(){return this._flags}hasFlag(e){return(this._flags&e)>0}get data(){return this._data}get proof(){return this._proof}set proof(e){this._proof=e}}Transaction.Format={BASIC:0,EXTENDED:1},Transaction.Flag={NONE:0,CONTRACT_CREATION:1,ALL:1},Transaction.FORMAT_MAP=new Map,Class.register(Transaction);class SignatureProof{static verifyTransaction(e){try{const t=new SerialBuffer(e.proof),r=SignatureProof.unserialize(t);return t.readPos!==t.byteLength?(Log.w(SignatureProof,"Invalid SignatureProof - overlong"),!1):r.verify(e.sender,e.serializeContent())}catch(e){return Log.w(SignatureProof,`Failed to verify transaction: ${e.message||e}`,e),!1}}static singleSig(e,t){return new SignatureProof(e,new MerklePath([]),t)}static multiSig(e,t,r){const i=MerklePath.compute(t,e);return new SignatureProof(e,i,r)}constructor(e,t,r){if(!(e instanceof PublicKey))throw new Error("Malformed publickKey");if(!(t instanceof MerklePath))throw new Error("Malformed merklePath");if(r&&!(r instanceof Signature))throw new Error("Malformed signature");this._publicKey=e,this._merklePath=t,this._signature=r}static unserialize(e){const t=PublicKey.unserialize(e),r=MerklePath.unserialize(e),i=Signature.unserialize(e);return new SignatureProof(t,r,i)}serialize(e){return e=e||new SerialBuffer(this.serializedSize),this._publicKey.serialize(e),this._merklePath.serialize(e),this._signature&&this._signature.serialize(e),e}get serializedSize(){return this._publicKey.serializedSize+this._merklePath.serializedSize+(this._signature?this._signature.serializedSize:0)}equals(e){return e instanceof SignatureProof&&this._publicKey.equals(e._publicKey)&&this._merklePath.equals(e._merklePath)&&(this._signature?this._signature.equals(e._signature):this._signature===e._signature)}verify(e,t){return null===e||this.isSignedBy(e)?this._signature?!!this._signature.verify(this._publicKey,t)||(Log.w(SignatureProof,"Invalid SignatureProof - signature is invalid"),!1):(Log.w(SignatureProof,"Invalid SignatureProof - signature is missing"),!1):(Log.w(SignatureProof,"Invalid SignatureProof - signer does not match sender address"),!1)}isSignedBy(e){const t=this._merklePath.computeRoot(this._publicKey);return Address.fromHash(t).equals(e)}get publicKey(){return this._publicKey}get merklePath(){return this._merklePath}get signature(){return this._signature}set signature(e){this._signature=e}}Class.register(SignatureProof);class BasicTransaction extends Transaction{constructor(e,t,r,i,s,n){if(!(e instanceof PublicKey))throw new Error("Malformed senderPubKey");if(void 0!==n&&!(n instanceof Signature))throw new Error("Malformed signature");const o=SignatureProof.singleSig(e,n);super(Transaction.Format.BASIC,e.toAddress(),Account.Type.BASIC,t,Account.Type.BASIC,r,i,s,Transaction.Flag.NONE,new Uint8Array(0),o.serialize()),this._signatureProof=o}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.BASIC);const r=PublicKey.unserialize(e),i=Address.unserialize(e),s=e.readUint64(),n=e.readUint64(),o=e.readUint32(),a=Signature.unserialize(e);return new BasicTransaction(r,i,s,n,o,a)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.BASIC),this.senderPubKey.serialize(e),this._recipient.serialize(e),e.writeUint64(this._value),e.writeUint64(this._fee),e.writeUint32(this._validityStartHeight),this.signature.serialize(e),e}get serializedSize(){return 1+this.senderPubKey.serializedSize+this._recipient.serializedSize+8+8+4+this.signature.serializedSize}get senderPubKey(){return this._signatureProof.publicKey}get signature(){return this._signatureProof.signature}set signature(e){this._signatureProof.signature=e,this._proof=this._signatureProof.serialize()}}Transaction.FORMAT_MAP.set(Transaction.Format.BASIC,BasicTransaction),Class.register(BasicTransaction);class ExtendedTransaction extends Transaction{constructor(e,t,r,i,s,n,o,a,l,c=new Uint8Array(0)){super(Transaction.Format.EXTENDED,e,t,r,i,s,n,o,a,l,c)}static unserialize(e){const t=e.readUint8();Assert.that(t===Transaction.Format.EXTENDED);const r=e.readUint16(),i=e.read(r),s=Address.unserialize(e),n=e.readUint8(),o=Address.unserialize(e),a=e.readUint8(),l=e.readUint64(),c=e.readUint64(),h=e.readUint32(),u=e.readUint8(),_=e.readUint16(),d=e.read(_);return new ExtendedTransaction(s,n,o,a,l,c,h,u,i,d)}serialize(e){return(e=e||new SerialBuffer(this.serializedSize)).writeUint8(Transaction.Format.EXTENDED),this.serializeContent(e),e.writeUint16(this._proof.byteLength),e.write(this._proof),e}get serializedSize(){return 1+this.serializedContentSize+2+this._proof.byteLength}}Transaction.FORMAT_MAP.set(Transaction.Format.EXTENDED,ExtendedTransaction),Class.register(ExtendedTransaction);
//# sourceMappingURL=worker.js.map
